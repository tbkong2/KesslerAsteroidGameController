# -*- coding: utf-8 -*-
"""MyTeamController.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EWEhqpTCeuWx9lL4XRgTRgfIntwrEjre
"""

# ECE 449 Kessler Game Project
# Group members: Tony Kong, Dominic Banaag Matienzo, Basma Ebeid
from kesslergame import KesslerController
import numpy as np
import math
import skfuzzy as fuzz
from skfuzzy import control as ctrl
import random
from typing import Dict, Tuple

import math
import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl
from kesslergame import KesslerController, KesslerGame, GraphicsType

BEST_GENOME = [
    -0.13124900651946614,
     0.09811465739887462,
    -0.2518494501920381,
    -0.5390561842191335,
    -0.15460610966546606,
     0.7204117473702536
]
def decode_genome_to_params(genome):
    def scale(g, low, high):
        return low + (g + 1.0) * 0.5 * (high - low)

    return {
        "thrust_scale": scale(genome[0], 1.2, 2.5),
        "chase_scale":  scale(genome[1], 1.2, 2.5),
        "back_scale":   scale(genome[2], 0.5, 1.5),
        "aim_angle_scale": scale(genome[3], 1.0, 2.0),
        "safe_dist_scale": scale(genome[4], 0.7, 1.5),
        "fire_bias": scale(genome[5], -0.2, 0.5)
    }
class FuzzyController(KesslerController):
    """Fuzzy controller for Kessler Game (thrust, turn, fire, drop_mine)."""


    def __init__(self, params=None):
        super().__init__()

        if params is None:
            self.params = decode_genome_to_params(BEST_GENOME)
        else:
            self.params = params

        self.action_control = self._build_fuzzy()


    def _build_fuzzy(self):

        # Inputs
        distance = ctrl.Antecedent(np.arange(0, 2000, 1), 'distance')
        angle = ctrl.Antecedent(np.arange(-math.pi, math.pi, 0.01), 'angle')

        # Outputs
        ship_turn   = ctrl.Consequent(np.arange(-180, 181, 1), 'ship_turn')
        ship_thrust = ctrl.Consequent(np.arange(-200, 201, 1), 'ship_thrust')
        ship_fire   = ctrl.Consequent(np.arange(-1, 1.1, 0.1), 'ship_fire')
        drop_mine   = ctrl.Consequent(np.arange(-1, 1.1, 0.1), 'drop_mine')

        # Distance sets
        distance['close'] = fuzz.trimf(distance.universe, [0, 0, 80])
        distance['mid']   = fuzz.trimf(distance.universe, [80, 750, 1200])
        distance['far']   = fuzz.trimf(distance.universe, [900, 2000, 2000])

        # Angle sets (relative asteroid angle)
        angle['NL'] = fuzz.trimf(angle.universe, [-math.pi, -math.pi/2, -math.pi/4])
        angle['NS'] = fuzz.trimf(angle.universe, [-math.pi/4, -0.2, 0])
        angle['Z']  = fuzz.trimf(angle.universe, [-0.05, 0, 0.05])
        angle['PS'] = fuzz.trimf(angle.universe, [0, 0.2, math.pi/4])
        angle['PL'] = fuzz.trimf(angle.universe, [math.pi/4, math.pi/2, math.pi])

        # Turn sets
        ship_turn['NL'] = fuzz.trimf(ship_turn.universe, [-180, -120, -60])
        ship_turn['NS'] = fuzz.trimf(ship_turn.universe, [-90, -45, 0])
        ship_turn['Z']  = fuzz.trimf(ship_turn.universe, [-5, 0, 5])
        ship_turn['PS'] = fuzz.trimf(ship_turn.universe, [0, 45, 90])
        ship_turn['PL'] = fuzz.trimf(ship_turn.universe, [60, 120, 180])

        # Thrust sets
        ship_thrust['BackStrong'] = fuzz.trimf(ship_thrust.universe, [-200, -200, -80])
        ship_thrust['Back']       = fuzz.trimf(ship_thrust.universe, [-100, -50, 0])
        ship_thrust['Stop']       = fuzz.trimf(ship_thrust.universe, [-10, 0, 10])
        ship_thrust['Fwd']        = fuzz.trimf(ship_thrust.universe, [0, 80, 150])
        ship_thrust['Chase']      = fuzz.trimf(ship_thrust.universe, [100, 180, 200])

        # Fire sets
        ship_fire['No']  = fuzz.trimf(ship_fire.universe, [-1, -1, -0.2])
        ship_fire['Yes'] = fuzz.trimf(ship_fire.universe, [0.2, 1, 1])

        # Mine sets
        drop_mine['No']  = fuzz.trimf(drop_mine.universe, [-1, -1, -0.2])
        drop_mine['Yes'] = fuzz.trimf(drop_mine.universe, [0.2, 1, 1])

        rules = []

        # Mid range, centered → sit and fire
        rules.append(
            ctrl.Rule(distance['mid'] & angle['Z'],
                      (ship_turn['Z'], ship_thrust['Stop'], ship_fire['Yes'], drop_mine['No']))
        )

        # Far, centered → move in and fire
        rules.append(
            ctrl.Rule(distance['far'] & angle['Z'],
                      (ship_turn['Z'], ship_thrust['Fwd'], ship_fire['Yes'], drop_mine['No']))
        )

        # Mid, slight error → small turn, keep position, fire
        rules.append(
            ctrl.Rule(distance['mid'] & angle['NS'],
                      (ship_turn['NS'], ship_thrust['Stop'], ship_fire['Yes'], drop_mine['No']))
        )
        rules.append(
            ctrl.Rule(distance['mid'] & angle['PS'],
                      (ship_turn['PS'], ship_thrust['Stop'], ship_fire['Yes'], drop_mine['No']))
        )

        # Far, slight error → turn and chase, fire
        rules.append(
            ctrl.Rule(distance['far'] & angle['NS'],
                      (ship_turn['NS'], ship_thrust['Chase'], ship_fire['Yes'], drop_mine['No']))
        )
        rules.append(
            ctrl.Rule(distance['far'] & angle['PS'],
                      (ship_turn['PS'], ship_thrust['Chase'], ship_fire['Yes'], drop_mine['No']))
        )

        # Mid, big error → turn towards target, move forward, don't fire
        rules.append(
            ctrl.Rule(distance['mid'] & angle['NL'],
                      (ship_turn['NL'], ship_thrust['Fwd'], ship_fire['No'], drop_mine['No']))
        )
        rules.append(
            ctrl.Rule(distance['mid'] & angle['PL'],
                      (ship_turn['PL'], ship_thrust['Fwd'], ship_fire['No'], drop_mine['No']))
        )

        # Far, big error → turn and chase, don't fire
        rules.append(
            ctrl.Rule(distance['far'] & angle['NL'],
                      (ship_turn['NL'], ship_thrust['Chase'], ship_fire['No'], drop_mine['No']))
        )
        rules.append(
            ctrl.Rule(distance['far'] & angle['PL'],
                      (ship_turn['PL'], ship_thrust['Chase'], ship_fire['No'], drop_mine['No']))
        )

        # Close in front/side → hard reverse, spray bullets, no mines
        rules.append(
            ctrl.Rule(distance['close'] & (angle['Z'] | angle['NS'] | angle['PS']),
                      (ship_turn['Z'], ship_thrust['BackStrong'], ship_fire['Yes'], drop_mine['No']))
        )

        # Close behind → push forward
        rules.append(
            ctrl.Rule(distance['close'] & (angle['NL'] | angle['PL']),
                      (ship_turn['Z'], ship_thrust['Chase'], ship_fire['Yes'], drop_mine['No']))
        )

        return ctrl.ControlSystem(rules)

    def actions(self, ship_state, game_state):
        """Compute thrust, turn, fire, and mine from fuzzy rules."""

        ship_x, ship_y = ship_state["position"]
        heading_deg = ship_state["heading"]

        # Closest asteroid
        closest = min(
            game_state["asteroids"],
            key=lambda a: math.dist((ship_x, ship_y), a["position"])
        )
        ax, ay = closest["position"]

        # Distance and angle to closest asteroid
        dx = ax - ship_x
        dy = ay - ship_y
        distance = math.dist((ship_x, ship_y), (ax, ay))

        ship_angle = math.radians(heading_deg)
        desired_angle = math.atan2(dy, dx)

        # Relative angle (wrapped to [-pi, pi])
        angle_error = (desired_angle - ship_angle + math.pi) % (2 * math.pi) - math.pi

        # Clamp inputs into universe ranges
        distance = max(0, min(distance, 2000))
        angle_error = max(-math.pi, min(angle_error, math.pi))

        # Run fuzzy controller
        sim = ctrl.ControlSystemSimulation(self.action_control)
        sim.input['distance'] = distance
        sim.input['angle'] = angle_error

        try:
            sim.compute()
        except Exception as e:
            print("FUZZY ERROR:", e)
            return 0.0, 0.0, False, False

        turn_val      = sim.output.get('ship_turn', 0.0)
        thrust_val    = sim.output.get('ship_thrust', 0.0)
        fire_val      = sim.output.get('ship_fire', -1.0)
        drop_mine_val = sim.output.get('drop_mine', -1.0)

        fire = fire_val > 0.0
        drop_mine = drop_mine_val > 0.0

        # Small extra accuracy tweak at longer range
        AIM_FIRE_ANGLE = math.radians(8 * self.params["aim_angle_scale"])
        SAFE_FIRE_DIST = 80 * self.params["safe_dist_scale"]

        thrust_val = thrust_val * self.params["thrust_scale"]
        if thrust_val > 0:
            thrust_val = thrust_val * self.params["chase_scale"]
        elif thrust_val < 0:
            thrust_val = thrust_val * self.params["back_scale"]
        # skip if it equals to 0
        fire = (fire + self.params["fire_bias"]) > 0
        drop_mine = (drop_mine_val + self.params["fire_bias"]) > 0



        if abs(angle_error) < math.radians(10):
          fire = True

        elif distance > SAFE_FIRE_DIST:
          fire = False



        return float(thrust_val), float(turn_val), bool(fire), bool(drop_mine)

    @property
    def name(self):
        return "My_Controller"




#TRAINING ONLY

#from scenario_test import my_test_scenario
#scenarios = [my_test_scenario]
#ga = GeneticOptimizer(population_size = 20, mutation_rate = 0.15)
#genome = ga.evolve(scenarios = scenarios, generations=15)
#print("\n======================")
#print("BEST GENOME FOUND:")
#print(genome)
#BEST_GENOME = [-0.13124900651946614, 0.09811465739887462, -0.2518494501920381, -0.5390561842191335, -0.15460610966546606, 0.7204117473702536]

